// ===== MiniKit World App Config - VERIFICACI√ìN WORLD ID REAL =====

// ===== Referencias UI =====
const btn = document.getElementById("wldSignIn");
const splash = document.getElementById("splash");
const state = document.getElementById("wldState");
const refillBtn = document.getElementById("refillBtn");
const debugInfo = document.getElementById("debugInfo");

// ===== Helpers UI =====
function msg(t) {
  if (state) {
    state.textContent = t;
    state.style.opacity = "1";
  }
  console.log("üîî", t);
}

function debugLog(message) {
  console.log(message);
  if (window.DEBUG_MODE && debugInfo) {
    debugInfo.innerHTML += message + '<br>';
    debugInfo.scrollTop = debugInfo.scrollHeight;
  }
}

function unlock() {
  document.querySelectorAll("#coin,.btn-icon,.fab").forEach(el => {
    el.style.pointerEvents = "";
  });
  if (splash) {
    splash.classList.add("splash-hide");
    setTimeout(() => splash.remove(), 450);
  }
  try { playSnd && playSnd("join", { volume: 0.9 }); } catch (_) {}
}

// ===== Detecci√≥n estricta de World App =====
function detectWorldApp() {
  const ua = navigator.userAgent.toLowerCase();
  const isWorldAppUA = ua.includes("worldapp") || ua.includes("world app") || ua.includes("worldcoin");
  
  // Detectar propiedades espec√≠ficas de World App
  const hasWorldAppProps = !!(
    window.worldapp || 
    window.WorldApp || 
    window.webkit?.messageHandlers?.worldapp ||
    window.Android?.worldapp ||
    navigator.userAgent.includes("WorldApp")
  );
  
  debugLog(`üîç User Agent: ${navigator.userAgent}`);
  debugLog(`üì± World App in UA: ${isWorldAppUA}`);
  debugLog(`üîß World App props: ${hasWorldAppProps}`);
  
  return isWorldAppUA || hasWorldAppProps;
}

// ===== Esperar MiniKit con timeout estricto =====
function waitForMiniKit(maxWaitSeconds = 10) {
  return new Promise((resolve, reject) => {
    let attempts = 0;
    const maxAttempts = maxWaitSeconds * 10; // Check every 100ms
    
    const checkMiniKit = () => {
      attempts++;
      
      // Buscar MiniKit en diferentes ubicaciones
      const minikit = window.MiniKit || window.minikit || window.WorldCoin || window.worldcoin;
      
      if (minikit && typeof minikit === 'object') {
        debugLog("‚úÖ MiniKit encontrado!");
        debugLog(`üìã MiniKit type: ${typeof minikit}`);
        debugLog(`üîß MiniKit keys: ${Object.keys(minikit)}`);
        
        // Verificar que tenga funciones de verificaci√≥n
        const hasVerify = !!(
          minikit.verify || 
          minikit.commands?.verify || 
          minikit.commandsAsync?.verify
        );
        
        if (hasVerify) {
          debugLog("‚úÖ MiniKit con funciones de verificaci√≥n encontrado");
          resolve(minikit);
          return;
        } else {
          debugLog("‚ö†Ô∏è MiniKit sin funciones de verificaci√≥n");
        }
      }
      
      if (attempts % 50 === 0) { // Log every 5 seconds
        debugLog(`üîç Esperando MiniKit... intento ${attempts}/${maxAttempts}`);
      }
      
      if (attempts >= maxAttempts) {
        debugLog("‚ùå MiniKit no disponible despu√©s de " + maxWaitSeconds + " segundos");
        reject(new Error("MiniKit no disponible"));
        return;
      }
      
      setTimeout(checkMiniKit, 100);
    };
    
    checkMiniKit();
  });
}

// ===== VERIFICACI√ìN WORLD ID REAL =====
export async function startVerify() {
  try {
    msg("üîç Iniciando verificaci√≥n World ID...");
    debugLog("üöÄ startVerify() llamado");

    const isWorldApp = detectWorldApp();
    debugLog(`üåç ¬øEs World App? ${isWorldApp}`);

    // SOLO usar desarrollo si NO est√° en World App
    if (!isWorldApp) {
      debugLog("üß™ NO es World App - modo desarrollo");
      msg("üß™ Modo desarrollo activo");
      
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // Crear datos de desarrollo
      const mockData = {
        action: "rainbowgold-login",
        signal: "",
        payload: {
          proof: `dev_proof_${Date.now()}`,
          merkle_root: `dev_merkle_${Date.now()}`,
          nullifier_hash: `dev_nullifier_${Math.random().toString(36).substr(2, 16)}`,
          verification_level: "device"
        }
      };
      
      return await sendVerificationToBackend(mockData, true);
    }

    // ESTAMOS EN WORLD APP - USAR VERIFICACI√ìN REAL
    msg("üåç World App detectada - iniciando World ID real");
    debugLog("üåç World App confirmada - procediendo con verificaci√≥n real");
    
    msg("‚è≥ Cargando MiniKit...");
    let MiniKit;
    
    try {
      MiniKit = await waitForMiniKit(10);
      debugLog("‚úÖ MiniKit cargado exitosamente");
    } catch (error) {
      debugLog("‚ùå Error cargando MiniKit: " + error.message);
      msg("‚ùå Error: MiniKit no disponible en World App");
      throw new Error("MiniKit no disponible - verifica que est√©s en World App actualizada");
    }

    // LANZAR LA VERIFICACI√ìN REAL DE WORLD ID
    msg("üîê Lanzando verificaci√≥n World ID...");
    debugLog("üé¨ LANZANDO INTERFAZ NATIVA DE WORLD ID");
    
    // Par√°metros EXACTOS para World ID
    const verifyParams = {
      action: "rainbowgold-login", // Debe estar registrado en tu World ID app
      signal: "", // Datos adicionales opcionales
      verification_level: "orb" // "orb" para verificaci√≥n completa
    };
    
    debugLog("üì§ Par√°metros World ID: " + JSON.stringify(verifyParams));
    debugLog("üéØ Llamando a MiniKit.verify() - DEBER√çA MOSTRAR INTERFAZ");

    // Determinar funci√≥n de verificaci√≥n disponible
    let verifyFunction = null;
    let methodUsed = "";
    
    if (MiniKit.commandsAsync?.verify) {
      verifyFunction = MiniKit.commandsAsync.verify;
      methodUsed = "commandsAsync.verify";
    } else if (MiniKit.commands?.verify) {
      verifyFunction = MiniKit.commands.verify;
      methodUsed = "commands.verify";
    } else if (typeof MiniKit.verify === 'function') {
      verifyFunction = MiniKit.verify;
      methodUsed = "verify";
    } else {
      debugLog("‚ùå NO HAY FUNCI√ìN DE VERIFICACI√ìN DISPONIBLE");
      debugLog("üîß M√©todos MiniKit disponibles: " + Object.keys(MiniKit));
      throw new Error("MiniKit no tiene m√©todo de verificaci√≥n");
    }

    debugLog(`üîß Usando m√©todo: MiniKit.${methodUsed}`);
    msg("üé¨ Abriendo World ID...");

    try {
      debugLog("üöÄ EJECUTANDO VERIFICACI√ìN - INTERFAZ DEBER√çA APARECER AHORA");
      
      // ESTA LLAMADA DEBER√çA MOSTRAR LA INTERFAZ DE WORLD ID
      const result = await verifyFunction.call(MiniKit.commandsAsync || MiniKit.commands || MiniKit, verifyParams);
      
      debugLog("üì• Resultado de World ID: " + JSON.stringify(result));
      
      // Manejar respuesta
      let finalPayload = result;
      if (result.finalPayload) {
        finalPayload = result.finalPayload;
        debugLog("üì¶ Usando finalPayload");
      }
      
      // Verificar √©xito
      if (!finalPayload) {
        debugLog("‚ùå Sin payload de respuesta");
        msg("‚ùå Sin respuesta de World ID");
        return;
      }
      
      if (finalPayload.status !== "success") {
        debugLog("‚ùå World ID no exitoso: " + JSON.stringify(finalPayload));
        
        if (finalPayload.status === "error") {
          msg("‚ùå Error: " + (finalPayload.message || "Verificaci√≥n fall√≥"));
        } else {
          msg("‚ùå Verificaci√≥n cancelada o fall√≥");
        }
        return;
      }
      
      debugLog("‚úÖ WORLD ID VERIFICACI√ìN EXITOSA!");
      msg("‚úÖ World ID verificado correctamente");
      
      // Crear payload para backend
      const backendPayload = {
        action: verifyParams.action,
        signal: verifyParams.signal,
        payload: {
          proof: finalPayload.proof,
          merkle_root: finalPayload.merkle_root,
          nullifier_hash: finalPayload.nullifier_hash,
          verification_level: finalPayload.verification_level || "orb"
        }
      };
      
      return await sendVerificationToBackend(backendPayload, false);
      
    } catch (verifyError) {
      debugLog("üí• ERROR EN VERIFICACI√ìN WORLD ID: " + verifyError.message);
      debugLog("üîç Stack trace: " + verifyError.stack);
      
      if (verifyError.message.includes("cancelled") || verifyError.message.includes("canceled")) {
        msg("‚ùå Verificaci√≥n cancelada por el usuario");
      } else if (verifyError.message.includes("timeout")) {
        msg("‚ùå Timeout - intenta de nuevo");
      } else if (verifyError.message.includes("not_verified")) {
        msg("‚ùå No verificado - necesitas verificar tu World ID");
      } else {
        msg("‚ùå Error World ID: " + verifyError.message);
      }
      
      // En World App, NO hacer fallback - mostrar error real
      throw verifyError;
    }

  } catch (error) {
    debugLog("üí• ERROR GENERAL: " + error.message);
    console.error("‚ùå Error en startVerify:", error);
    
    msg("‚ùå " + error.message);
    
    // NO hacer fallback en World App - mostrar error real
    if (detectWorldApp()) {
      throw error;
    }
  }
}

// ===== Enviar al backend =====
async function sendVerificationToBackend(payload, isDev = false) {
  try {
    msg(isDev ? "üì§ Enviando datos de desarrollo..." : "üì§ Validando con backend...");
    
    debugLog("üì§ Payload al backend: " + JSON.stringify(payload));

    const res = await fetch(`${window.API_BASE}/api/verify`, {
      method: "POST",
      headers: { 
        "Content-Type": "application/json",
        "Accept": "application/json"
      },
      body: JSON.stringify(payload)
    });

    debugLog(`üì• Backend response: ${res.status} ${res.statusText}`);

    if (!res.ok) {
      const text = await res.text().catch(() => "");
      debugLog("‚ùå Backend error: " + text);
      throw new Error(`Backend error: ${res.status}`);
    }

    const data = await res.json();
    debugLog("‚úÖ Backend success: " + JSON.stringify(data));

    if (data.ok && data.verified) {
      window.VERIFIED = true;
      window.SESSION_TOKEN = data.token;
      window.USER_ID = data.userId;
      
      // Aplicar estado del juego
      if (data.state) {
        try {
          window.wld = +data.state.wld || 0;
          window.rbgp = +data.state.rbgp || 0;
          window.energy = +data.state.energy || 100;
          debugLog("üéÆ Estado aplicado");
        } catch (e) {
          debugLog("‚ö†Ô∏è Error aplicando estado: " + e.message);
        }
      }
      
      // UI updates
      try { 
        setVerifiedUI?.(true);
        render?.(); 
      } catch (_) {}
      
      unlock();
      msg(isDev ? "‚úÖ Modo desarrollo listo" : "‚úÖ ¬°Verificado con World ID!");
      return true;
      
    } else {
      msg("‚ùå Backend rechaz√≥: " + (data.error || "unknown"));
      return false;
    }

  } catch (error) {
    debugLog("üí• Backend error: " + error.message);
    msg("‚ùå Error backend: " + error.message);
    return false;
  }
}

// ===== Event Listeners =====
if (btn) {
  btn.addEventListener("click", async (ev) => {
    ev.preventDefault();
    btn.disabled = true;
    const original = btn.textContent;
    btn.style.opacity = "0.6";
    btn.textContent = "Verificando...";
    
    try { 
      await startVerify(); 
    } catch (error) {
      debugLog("üí• Click error: " + error.message);
    } finally {
      btn.disabled = false;
      btn.style.opacity = "1";
      btn.textContent = original;
    }
  });
}

// ===== Inicializaci√≥n =====
document.addEventListener("DOMContentLoaded", async () => {
  debugLog("üì± MiniKit config iniciado");
  
  const isWA = detectWorldApp();
  if (isWA) {
    msg("üåç World App - World ID real disponible");
  } else {
    msg("üß™ Navegador externo - modo desarrollo");
  }
});

// Export para uso global
window.startVerify = startVerify;